/**
 * @file EKF集成快速使用指南
 * @brief 如何在N-Car项目中使用EKF算法
 */

/*=============================================================================
 * 一、快速上手（通过菜单切换）
 *=============================================================================*/

// 步骤1：上电后进入菜单
//   Main Menu → IMU → IMU Params

// 步骤2：选择算法
//   找到 "Algorithm(0/1)" 参数
//   - 0 = 一阶互补滤波（默认，原算法）
//   - 1 = EKF扩展卡尔曼滤波（新算法）

// 步骤3：调整参数
//   按 OK 键进入调整模式
//   按 UP/DOWN 切换算法（0或1）
//   按 BACK 退出并自动保存

// 步骤4：重启生效
//   算法切换后需要重启设备才能生效

/*=============================================================================
 * 二、代码集成说明
 *=============================================================================*/

// 1. 新增文件
// code/EKF/
//   - Attitude.c/h          姿态解算接口
//   - QuaternionEKF.c/h     四元数EKF核心
//   - kalman_filter.c/h     卡尔曼滤波库
//   - matrix.c/h            矩阵运算库

// 2. 修改的文件
// code/imu.h
//   + 添加 imu_algorithm_t 枚举
//   + 添加 imu_algorithm_select 全局变量
//   + 保留所有原有接口

// code/imu.c
//   + 添加 imu_calculate_attitude_ekf() - EKF算法
//   + 添加 imu_calculate_attitude_complementary() - 原算法
//   + 修改 imu_calculate_attitude() - 自动选择算法
//   + 修改 imu_init() - 支持两种算法初始化
//   * 保留所有原有代码，仅封装到函数中

// code/menu.c
//   + 在 IMU Params 页面添加 "Algorithm(0/1)" 参数
//   + 更新 page_imu_params.len 从 3 改为 4

/*=============================================================================
 * 三、算法对比
 *=============================================================================*/

// 一阶互补滤波（原算法）
// ✓ 计算速度快，CPU占用低
// ✓ 代码简单，易于理解
// ✗ 只输出pitch角
// ✗ 精度一般
// ✗ 无法估计陀螺仪零偏
// 适用场景：简单平衡控制，对精度要求不高

// 扩展卡尔曼滤波（EKF）
// ✓ 精度高，鲁棒性强
// ✓ 输出完整三轴姿态（roll/pitch/yaw）
// ✓ 自适应估计陀螺仪零偏
// ✓ 更好的抗干扰能力
// ✗ 计算量较大
// ✗ 参数调优复杂
// 适用场景：高精度姿态估计，复杂运动控制

/*=============================================================================
 * 四、调试示例
 *=============================================================================*/

// 在 cpu0_main.c 的 Cargo 模式中打印姿态数据
void example_print_attitude(void)
{
    if (enable && imu_algorithm_select == IMU_ALGORITHM_EKF)
    {
        // EKF模式：打印三轴姿态
        printf("R:%0.2f,P:%0.2f,Y:%0.2f,Gy:%d\r\n",
               imu_data.roll,   // 横滚角
               imu_data.pitch,  // 俯仰角
               imu_data.yaw,    // 偏航角
               imu_data.gyro_y  // 陀螺仪Y轴
        );
    }
    else
    {
        // 互补滤波模式：打印pitch角
        printf("P:%0.2f,Gy:%d\r\n",
               imu_data.pitch,  // 俯仰角
               imu_data.gyro_y  // 陀螺仪Y轴
        );
    }
}

/*=============================================================================
 * 五、EKF参数调优
 *=============================================================================*/

// 在 imu_init() 中修改 EKF 初始化参数
void example_ekf_tuning(void)
{
    // 默认参数
    IMU_QuaternionEKF_Init(
        100,        // process_noise1: 四元数过程噪声（越大越灵敏）
        0.00001,    // process_noise2: 陀螺仪零偏过程噪声
        100000000,  // measure_noise: 加速度计量测噪声（越大越信任陀螺仪）
        0.9996,     // lambda: 渐消因子（接近1）
        0.001f,     // dt: 更新周期（1ms）
        0           // lpf: 低通滤波系数
    );

    // 如果姿态跟踪过慢，可以尝试：
    // IMU_QuaternionEKF_Init(200, 0.0001, 50000000, 0.999, 0.001f, 0);

    // 如果抖动太大，可以尝试：
    // IMU_QuaternionEKF_Init(50, 0.000001, 200000000, 0.9998, 0.001f, 0);
}

/*=============================================================================
 * 六、故障排查
 *=============================================================================*/

// 问题1：切换到EKF后姿态角异常
// 原因：陀螺仪零偏未校准或机械中值不正确
// 解决：
//   1. 进入 Main Menu → IMU → Calibrate 进行校准
//   2. 检查 Main Menu → Angle PID → Mech Zero 机械中值

// 问题2：EKF输出抖动严重
// 原因：加速度计受振动干扰或EKF参数不合适
// 解决：
//   1. 检查传感器安装是否牢固
//   2. 增大 measure_noise 参数（减少加速度计权重）
//   3. 减小 process_noise1 参数（降低灵敏度）

// 问题3：姿态角方向错误
// 原因：坐标系定义不匹配
// 解决：在 imu_calculate_attitude_ekf() 中调整正负号

// 问题4：编译错误
// 原因：缺少EKF库文件或路径配置不正确
// 解决：
//   1. 确认 code/EKF/ 文件夹存在且包含所有文件
//   2. 检查项目包含路径设置

/*=============================================================================
 * 七、性能数据（参考）
 *=============================================================================*/

// 测试平台：TC264D @ 200MHz
// 
// 一阶互补滤波：
//   - 执行时间：~10us
//   - 内存占用：<100 bytes
//   - 更新频率：500Hz (2ms周期)
//
// 扩展卡尔曼滤波：
//   - 执行时间：~100us (取决于优化等级)
//   - 内存占用：~2KB
//   - 更新频率：1000Hz (1ms周期)
//
// 注意：以上数据仅供参考，实际性能取决于编译器优化设置

/*=============================================================================
 * 八、后续优化建议
 *=============================================================================*/

// 1. 动态算法切换
//    支持运行时切换算法（无需重启）
//    需要添加状态重置逻辑

// 2. 参数自动调优
//    根据运动状态自动调整EKF参数
//    例如：静止时增加加速度计权重，运动时减少

// 3. 多传感器融合
//    添加磁力计数据融合（如果硬件支持）
//    提高yaw角估计精度

// 4. 异常检测
//    添加传感器数据异常检测
//    自动切换到备用算法

/*=============================================================================
 * 九、参考资料
 *=============================================================================*/

// 1. EKF原理：
//    - 《概率机器人》第3章 - 高斯滤波器
//    - 《惯性导航》第7章 - 卡尔曼滤波
//
// 2. 四元数姿态表示：
//    - https://www.zhihu.com/question/23005815
//    - 《Introduction to Robotics》第2章
//
// 3. IMU标定：
//    - https://github.com/ethz-asl/kalibr
//    - Allan方差分析方法

/*=============================================================================
 * 十、版本记录
 *=============================================================================*/

// v1.0 (2025-10-09)
//   - 初始集成EKF算法
//   - 支持菜单选择算法
//   - 保留原有互补滤波代码
//   - 添加详细文档

// 后续版本计划：
//   - v1.1: 添加运行时切换支持
//   - v1.2: 优化EKF计算性能
//   - v1.3: 添加磁力计融合（如果需要）
